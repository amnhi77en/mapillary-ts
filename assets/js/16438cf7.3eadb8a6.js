"use strict";(self.webpackChunkmapillary_js_doc=self.webpackChunkmapillary_js_doc||[]).push([[677],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return u}});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=r.createContext({}),d=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=d(e.components);return r.createElement(l.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},p=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),p=d(n),u=a,h=p["".concat(l,".").concat(u)]||p[u]||m[u]||o;return n?r.createElement(h,i(i({ref:t},c),{},{components:n})):r.createElement(h,i({ref:t},c))}));function u(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=p;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,i[1]=s;for(var d=2;d<o;d++)i[d]=n[d];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}p.displayName="MDXCreateElement"},8173:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return i},contentTitle:function(){return s},metadata:function(){return l},toc:function(){return d},default:function(){return m}});var r=n(2122),a=n(9756),o=(n(7294),n(3905)),i={id:"webgl-custom-renderer",title:"WebGL Renderer"},s=void 0,l={unversionedId:"extension/webgl-custom-renderer",id:"extension/webgl-custom-renderer",isDocsHomePage:!1,title:"WebGL Renderer",description:"MapillaryJS comes with a core set of visualization features. If you want augment the MapillaryJS experience you can extend it by rendering your own 3D objects. There are mulitple ways to do this, in this guide we will use the WebGL API.",source:"@site/docs/extension/webgl-custom-renderer.md",sourceDirName:"extension",slug:"/extension/webgl-custom-renderer",permalink:"/mapillary-js/docs/extension/webgl-custom-renderer",editUrl:"https://github.com/mapillary/mapillary-js/edit/main/doc/docs/extension/webgl-custom-renderer.md",tags:[],version:"current",frontMatter:{id:"webgl-custom-renderer",title:"WebGL Renderer"},sidebar:"docs",previous:{title:"Geometry Provider",permalink:"/mapillary-js/docs/extension/geometry-provider"},next:{title:"Three.js Renderer",permalink:"/mapillary-js/docs/extension/three-custom-renderer"}},d=[{value:"Creating a 3D Object",id:"creating-a-3d-object",children:[{value:"Geo Coordinates",id:"geo-coordinates",children:[]}]},{value:"Creating the Custom Renderer",id:"creating-the-custom-renderer",children:[{value:"<code>constructor</code>",id:"constructor",children:[]},{value:"<code>onAdd</code>",id:"onadd",children:[]},{value:"<code>onReference</code>",id:"onreference",children:[]},{value:"<code>onRemove</code>",id:"onremove",children:[]},{value:"<code>render</code>",id:"render",children:[]},{value:"Additional Functionality",id:"additional-functionality",children:[]}]},{value:"Adding the Renderer",id:"adding-the-renderer",children:[]},{value:"Recap",id:"recap",children:[]}],c={toc:d};function m(e){var t=e.components,n=(0,a.Z)(e,["components"]);return(0,o.kt)("wrapper",(0,r.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"MapillaryJS comes with a core set of visualization features. If you want augment the MapillaryJS experience you can extend it by rendering your own 3D objects. There are mulitple ways to do this, in this guide we will use the WebGL API."),(0,o.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,o.kt)("div",{parentName:"div",className:"admonition-heading"},(0,o.kt)("h5",{parentName:"div"},(0,o.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,o.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,o.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"You will learn")),(0,o.kt)("div",{parentName:"div",className:"admonition-content"},(0,o.kt)("ul",{parentName:"div"},(0,o.kt)("li",{parentName:"ul"},"How to use WebGL to render 3D objects directly into the MapillaryJS rendering context"),(0,o.kt)("li",{parentName:"ul"},"How to implement the ",(0,o.kt)("inlineCode",{parentName:"li"},"ICustomRenderer")," interface using the WebGL API"),(0,o.kt)("li",{parentName:"ul"},"How to add your renderer to the ",(0,o.kt)("inlineCode",{parentName:"li"},"Viewer"))))),(0,o.kt)("h2",{id:"creating-a-3d-object"},"Creating a 3D Object"),(0,o.kt)("p",null,"We will base our renderer on the ",(0,o.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Tutorial/Creating_3D_objects_using_WebGL"},"Creating 3D object usings WebGL tutorial")," on MDN and add a cube to the street 3D space in MapillaryJS."),(0,o.kt)("p",null,"The buffer and shader program setup in our code is very similar to the one in the MDN tutorial. First, we create a function to build the cube's vertex position buffer (and similarly the color and index buffers)."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"function initBuffers(gl) {\n  const positions = [\n    // Front\n    -1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0, 1.0, 1.0, -1.0, 1.0, 1.0,\n    // ...\n  ];\n\n  const positionBuffer = gl.createBuffer();\n  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);\n\n  // ...\n}\n")),(0,o.kt)("p",null,"Then, like in the MDN tutorial, we create a function to compile our shaders and initialize our shader program."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"function initShaderProgram(gl, vsSource, fsSource) {\n  const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);\n  const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);\n\n  const shaderProgram = gl.createProgram();\n  gl.attachShader(shaderProgram, vertexShader);\n  gl.attachShader(shaderProgram, fragmentShader);\n  gl.linkProgram(shaderProgram);\n\n  // ...\n\n  return {fragmentShader, shaderProgram, vertexShader};\n}\n")),(0,o.kt)("h3",{id:"geo-coordinates"},"Geo Coordinates"),(0,o.kt)("p",null,"From here on, our code will differ slightly from the MDN tutorial. We will go through why it differs."),(0,o.kt)("p",null,"First, entities rendered in MapillaryJS have geodetic coordiantes (or have a position relative to a geodetic reference coordinate) so we set its geo position. Also, instead of the combined ",(0,o.kt)("inlineCode",{parentName:"p"},"modelViewMatrix")," used in the MDN example, we will separate it into two matrices, the ",(0,o.kt)("inlineCode",{parentName:"p"},"modelMatrix")," and the ",(0,o.kt)("inlineCode",{parentName:"p"},"viewMatrix")," for clarity. The model matrix defines the transform of the model, in this case our cube. We initialize it to identity but will soon change that."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const cube = {\n  geoPosition: {\n    alt: 1,\n    lat: -25.28268614514251,\n    lng: -57.630922858385,\n  },\n  modelMatrix: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],\n};\n")),(0,o.kt)("p",null,"Our vertex shader is adjusted to use the ",(0,o.kt)("inlineCode",{parentName:"p"},"modelMatrix")," when calculating the ",(0,o.kt)("inlineCode",{parentName:"p"},"gl_Position")," accordingly."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const vertexShaderSource = `\n  attribute vec4 aVertexPosition;\n  attribute vec4 aVertexColor;\n\n  uniform mat4 uModelMatrix;\n  uniform mat4 uViewMatrix;\n  uniform mat4 uProjectionMatrix;\n\n  varying lowp vec4 vColor;\n\n  void main(void) {\n    gl_Position = uProjectionMatrix * uViewMatrix * uModelMatrix * aVertexPosition;\n    vColor = aVertexColor;\n  }\n`;\n")),(0,o.kt)("div",{className:"admonition admonition-tip alert alert--success"},(0,o.kt)("div",{parentName:"div",className:"admonition-heading"},(0,o.kt)("h5",{parentName:"div"},(0,o.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,o.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,o.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"tip")),(0,o.kt)("div",{parentName:"div",className:"admonition-content"},(0,o.kt)("p",{parentName:"div"},"If you want to learn more about model, view, and projection matrices, take a look at the ",(0,o.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_model_view_projection"},"WebGL model view projection article")," on MDN. Our custom renderer will rely on all three of them."))),(0,o.kt)("h2",{id:"creating-the-custom-renderer"},"Creating the Custom Renderer"),(0,o.kt)("p",null,"With the initialization code completed, we can can start implementing our custom renderer. To create it, we will implement the ",(0,o.kt)("a",{parentName:"p",href:"/api/interfaces/viewer.icustomrenderer"},"ICustomRenderer")," interface."),(0,o.kt)("p",null,"Let us go through it member by member."),(0,o.kt)("h3",{id:"constructor"},(0,o.kt)("inlineCode",{parentName:"h3"},"constructor")),(0,o.kt)("p",null,"We can use the constructor to assign readonly properties of our renderer. Every custom renderer needs to have a unique ID and specify its render pass (currently the only supported render pass is ",(0,o.kt)("inlineCode",{parentName:"p"},"Opaque"),"). These properties will not change so the constructor is a good place to assign them. Our cube will also be readonly so we assign it here as well."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"class WebGLCubeRenderer {\n  constructor(cube) {\n    this.id = 'webgl-cube-renderer';\n    this.renderPass = RenderPass.Opaque;\n    this.cube = cube;\n  }\n  // ...\n}\n")),(0,o.kt)("h3",{id:"onadd"},(0,o.kt)("inlineCode",{parentName:"h3"},"onAdd")),(0,o.kt)("p",null,"ICustomRenderer.",(0,o.kt)("a",{parentName:"p",href:"/api/interfaces/viewer.icustomrenderer#onadd"},"onAdd")," is called when the renderer has been added to the ",(0,o.kt)("inlineCode",{parentName:"p"},"Viewer")," with the Viewer.",(0,o.kt)("a",{parentName:"p",href:"/api/classes/viewer.Viewer#addcustomrenderer"},"addCustomRenderer")," method. This gives your renderer a chance to initialize WebGL resources and register event listeners. It is also a chance to calculate the ",(0,o.kt)("a",{parentName:"p",href:"/docs/theory/coordinates#local-topocentric-coordinates"},"local topocentric positions")," for scene objects using the provided reference."),(0,o.kt)("p",null,"To calculate the topocentric position of our cube, we will make use of the ",(0,o.kt)("a",{parentName:"p",href:"/api/modules/api#geodetictoenu"},"geodeticToEnu")," helper function in MapillaryJS and make a translation matrix by translating the cube according to the east, north, up coordinates."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"function makeTranslation(v) {\n  const [x, y, z] = v;\n  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, x, y, z, 1];\n}\n\nfunction makeModelMatrix(geoPosition, reference) {\n  const enuPosition = geodeticToEnu(\n    geoPosition.lng,\n    geoPosition.lat,\n    geoPosition.alt,\n    reference.lng,\n    reference.lat,\n    reference.alt,\n  );\n  const modelMatrix = makeTranslation(enuPosition);\n  return modelMatrix;\n}\n")),(0,o.kt)("div",{className:"admonition admonition-tip alert alert--success"},(0,o.kt)("div",{parentName:"div",className:"admonition-heading"},(0,o.kt)("h5",{parentName:"div"},(0,o.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,o.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,o.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"tip")),(0,o.kt)("div",{parentName:"div",className:"admonition-content"},(0,o.kt)("p",{parentName:"div"},"If you need to perform vector and matrix operations, we recommend using the ",(0,o.kt)("a",{parentName:"p",href:"https://glmatrix.net/"},"glMatrix")," library or the ",(0,o.kt)("a",{parentName:"p",href:"https://threejs.org/docs/index.html#api/en/math/Matrix4"},"Three.js math modules")," (like in the ",(0,o.kt)("a",{parentName:"p",href:"/examples/extend-three-renderer"},"Three.js Custom Renderer")," example)."))),(0,o.kt)("p",null,"With our helper functions, we can calculate the tranformation matrix of our cube model using the ",(0,o.kt)("inlineCode",{parentName:"p"},"reference")," parameter of the ",(0,o.kt)("inlineCode",{parentName:"p"},"onAdd")," method. With the context parameter we can initialize our shader program and buffers. We make sure to add the ",(0,o.kt)("inlineCode",{parentName:"p"},"modelMatrix")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"viewMatrix")," as uniforms to our program info."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"class WebGLCubeRenderer {\n  // ...\n  onAdd(viewer, reference, context) {\n    this.cube.modelMatrix = makeModelMatrix(this.cube.geoPosition, reference);\n\n    const gl = context;\n    const {fragmentShader, shaderProgram, vertexShader} = initShaderProgram(\n      gl,\n      vertexShaderSource,\n      fragmentShaderSource,\n    );\n\n    this.buffers = initBuffers(gl);\n    this.fragmentShader = fragmentShader;\n    this.vertexShader = vertexShader;\n    this.shaderProgram = shaderProgram;\n    this.programInfo = {\n      program: shaderProgram,\n      attribLocations: {\n        vertexPosition: gl.getAttribLocation(shaderProgram, 'aVertexPosition'),\n        vertexColor: gl.getAttribLocation(shaderProgram, 'aVertexColor'),\n      },\n      uniformLocations: {\n        modelMatrix: gl.getUniformLocation(shaderProgram, 'uModelMatrix'),\n        projectionMatrix: gl.getUniformLocation(\n          shaderProgram,\n          'uProjectionMatrix',\n        ),\n        viewMatrix: gl.getUniformLocation(shaderProgram, 'uViewMatrix'),\n      },\n    };\n  }\n}\n")),(0,o.kt)("h3",{id:"onreference"},(0,o.kt)("inlineCode",{parentName:"h3"},"onReference")),(0,o.kt)("p",null,"While we will only operate in a small area around the cube with our renderer, MapillaryJS operates on global earth scale. For different reasons, e.g. to ensure numeric stability by keeping topocentric coordinates sufficiently small, MapillaryJS will sometimes update its internal reference geo coordinate used to convert coordinates from geodetic to local topocentric reference. Whenever it updates the reference, it will notify our renderer by calling the ICustomRenderer.",(0,o.kt)("a",{parentName:"p",href:"/api/interfaces/viewer.icustomrenderer#onreference"},"onReference")," method so that we can act accordingly and recalculate our translation and assign a new ",(0,o.kt)("inlineCode",{parentName:"p"},"modelMatrix")," our cube. This does not mean the the cube moves relative to the street imagery. Instead, the earth sphere that MapillaryJS operates on has been rotated and we need to adjust everything we want to render accordingly."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"class WebGLCubeRenderer {\n  //...\n  onReference(viewer, reference) {\n    this.cube.modelMatrix = makeModelMatrix(this.cube.geoPosition, reference);\n  }\n}\n")),(0,o.kt)("h3",{id:"onremove"},(0,o.kt)("inlineCode",{parentName:"h3"},"onRemove")),(0,o.kt)("p",null,"ICustomRenderer.",(0,o.kt)("a",{parentName:"p",href:"/api/interfaces/viewer.icustomrenderer#onremove"},"onRemove")," is called when the renderer has been removed from the ",(0,o.kt)("inlineCode",{parentName:"p"},"Viewer")," with the Viewer.",(0,o.kt)("a",{parentName:"p",href:"/api/classes/viewer.Viewer#addcustomrenderer"},"removeCustomRenderer")," method. This gives us a chance to clean up our WebGL resources (and potential event listeners etc). Everything that we created in the ",(0,o.kt)("inlineCode",{parentName:"p"},"onAdd")," method should be dispose and cleaned up now."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"class WebGLCubeRenderer {\n  //...\n  onRemove(viewer, context) {\n    const {buffers, fragmentShader, shaderProgram, vertexShader} = this;\n\n    const gl = context;\n    gl.deleteProgram(shaderProgram);\n    gl.deleteShader(fragmentShader);\n    gl.deleteShader(vertexShader);\n\n    const {color, indices, position} = buffers;\n    gl.deleteBuffer(color);\n    gl.deleteBuffer(indices);\n    gl.deleteBuffer(position);\n  }\n}\n")),(0,o.kt)("h3",{id:"render"},(0,o.kt)("inlineCode",{parentName:"h3"},"render")),(0,o.kt)("p",null,"ICustomRenderer.",(0,o.kt)("a",{parentName:"p",href:"/api/interfaces/viewer.icustomrenderer#render"},"render")," is called during every animation frame that is run. It allows our renderer to draw into the WebGL context."),(0,o.kt)("div",{className:"admonition admonition-note alert alert--secondary"},(0,o.kt)("div",{parentName:"div",className:"admonition-heading"},(0,o.kt)("h5",{parentName:"div"},(0,o.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,o.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,o.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"note")),(0,o.kt)("div",{parentName:"div",className:"admonition-content"},(0,o.kt)("p",{parentName:"div"},"When the Viewer is halted, i.e. when no motion such as translation or rotation is performed, the animation frames are not run and therefore the ",(0,o.kt)("inlineCode",{parentName:"p"},"render")," method will not be called. See the ",(0,o.kt)("a",{parentName:"p",href:"/docs/extension/animation"},"Animation")," example for guidance into how to force all animation frames to be run and the render method to be called on every frame."))),(0,o.kt)("p",null,"Binding our vertex, color, and index buffers to WebGL attributes works exactly like in the MDN tutorial but we have to change some things regarding setup and uniforms. While the MDN tutorial clears the WebGL context, we do not want to clear anything and instead add content superimposed onto the MapillaryJS street imagery scene. Also, while the MDN tutorial sets up the WebGL view-model and projection matrices in its draw call, MapillaryJS provides the ",(0,o.kt)("inlineCode",{parentName:"p"},"viewMatrix")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"projectionMatrix")," as parameters. We will use them together with the cube ",(0,o.kt)("inlineCode",{parentName:"p"},"modelMatrix")," to set up our uniforms."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"render(context, viewMatrix, projectionMatrix) {\n    const gl = context;\n    const {buffers, programInfo} = this;\n    const {modelMatrix} = this.cube;\n\n    // ...\n\n    gl.useProgram(programInfo.program);\n    gl.uniformMatrix4fv(\n      programInfo.uniformLocations.modelMatrix,\n      false,\n      modelMatrix,\n    );\n    gl.uniformMatrix4fv(\n      programInfo.uniformLocations.projectionMatrix,\n      false,\n      projectionMatrix,\n    );\n    gl.uniformMatrix4fv(\n      programInfo.uniformLocations.viewMatrix,\n      false,\n      viewMatrix,\n    );\n\n    {\n      const vertexCount = 36;\n      const type = gl.UNSIGNED_SHORT;\n      const offset = 0;\n      gl.drawElements(gl.TRIANGLES, vertexCount, type, offset);\n    }\n  }\n}\n")),(0,o.kt)("div",{className:"admonition admonition-caution alert alert--warning"},(0,o.kt)("div",{parentName:"div",className:"admonition-heading"},(0,o.kt)("h5",{parentName:"div"},(0,o.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,o.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"16",height:"16",viewBox:"0 0 16 16"},(0,o.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"}))),"caution")),(0,o.kt)("div",{parentName:"div",className:"admonition-content"},(0,o.kt)("p",{parentName:"div"},"Your custom renderer cannot make assumptions about the current WebGL state. If you run into rendering problems with you custom renderers, resetting the WebGL state may help."))),(0,o.kt)("h3",{id:"additional-functionality"},"Additional Functionality"),(0,o.kt)("p",null,"In our custom renderer we only have a single fixed cube that is always visible. Maybe you want to add and remove objects dynamically, change object positions, or change object appearance during the lifespan of the renderer and application. To do that, you can add additional methods and functionality to your renderer class directly or in helpers."),(0,o.kt)("div",{className:"admonition admonition-note alert alert--secondary"},(0,o.kt)("div",{parentName:"div",className:"admonition-heading"},(0,o.kt)("h5",{parentName:"div"},(0,o.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,o.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,o.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"note")),(0,o.kt)("div",{parentName:"div",className:"admonition-content"},(0,o.kt)("p",{parentName:"div"},"As of this writing, MapillaryJS will always render the street imagery layer as a background. Occlusion between custom rendered objects and the street imagery will never occur, custom rendered objects will always be rendered on top of the street imagery. You can eperiment with transparency to assert object placement."))),(0,o.kt)("h2",{id:"adding-the-renderer"},"Adding the Renderer"),(0,o.kt)("p",null,"Now that we have implemented our custom cube renderer, we just need to add it to the ",(0,o.kt)("inlineCode",{parentName:"p"},"Viewer")," through the Viewer.",(0,o.kt)("a",{parentName:"p",href:"/api/classes/viewer.Viewer#addcustomrenderer"},"addCustomRenderer")," method."),(0,o.kt)("div",{className:"admonition admonition-tip alert alert--success"},(0,o.kt)("div",{parentName:"div",className:"admonition-heading"},(0,o.kt)("h5",{parentName:"div"},(0,o.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,o.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,o.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"tip")),(0,o.kt)("div",{parentName:"div",className:"admonition-content"},(0,o.kt)("p",{parentName:"div"},"Try changing the cube's geo position, for example the altitude, to see how it affects where it is placed in relation to the imagery."))),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx",metastring:"live",live:!0},"function render(props) {\n  let viewer;\n\n  function init(opts) {\n    const {accessToken, container} = opts;\n\n    const imageId = '3748064795322267';\n    const options = {\n      accessToken,\n      component: {cover: false},\n      container,\n    };\n    viewer = new Viewer(options);\n\n    const cube = {\n      geoPosition: {\n        alt: 1,\n        lat: -25.28268614514251,\n        lng: -57.630922858385,\n      },\n      modelMatrix: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],\n    };\n    const cubeRenderer = new webglrenderer.WebGLCubeRenderer(cube);\n    viewer.addCustomRenderer(cubeRenderer);\n\n    viewer.moveTo(imageId).catch(mapillaryErrorHandler);\n  }\n\n  function dispose() {\n    if (viewer) {\n      viewer.remove();\n    }\n  }\n\n  return (\n    <ViewerComponent init={init} dispose={dispose} style={{height: '400px'}} />\n  );\n}\n")),(0,o.kt)("h2",{id:"recap"},"Recap"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"To add your 3D objects to MapillaryJS, implement the ",(0,o.kt)("inlineCode",{parentName:"li"},"ICustomRenderer")," interface"),(0,o.kt)("li",{parentName:"ul"},"Make sure your objects have a geo position (or a position relative to a geo reference)"),(0,o.kt)("li",{parentName:"ul"},"Use the MapillaryJS geo reference parameter to translate your objects to local topocentric coordinates"),(0,o.kt)("li",{parentName:"ul"},"Add your custom renderer to the ",(0,o.kt)("inlineCode",{parentName:"li"},"Viewer")," to render directly into the MapillaryJS rendering context")),(0,o.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,o.kt)("div",{parentName:"div",className:"admonition-heading"},(0,o.kt)("h5",{parentName:"div"},(0,o.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,o.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,o.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"info")),(0,o.kt)("div",{parentName:"div",className:"admonition-content"},(0,o.kt)("p",{parentName:"div"},"You can view the complete code in the ",(0,o.kt)("a",{parentName:"p",href:"/examples/extend-webgl-renderer"},"WebGL Renderer")," example."))))}m.isMDXComponent=!0}}]);