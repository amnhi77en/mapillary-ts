"use strict";(self.webpackChunkmapillary_js_doc=self.webpackChunkmapillary_js_doc||[]).push([[3900],{3905:function(e,t,n){n.d(t,{Zo:function(){return m},kt:function(){return h}});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var c=a.createContext({}),s=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},m=function(e){var t=s(e.components);return a.createElement(c.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,c=e.parentName,m=l(e,["components","mdxType","originalType","parentName"]),d=s(n),h=o,u=d["".concat(c,".").concat(h)]||d[h]||p[h]||r;return n?a.createElement(u,i(i({ref:t},m),{},{components:n})):a.createElement(u,i({ref:t},m))}));function h(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,i=new Array(r);i[0]=d;var l={};for(var c in t)hasOwnProperty.call(t,c)&&(l[c]=t[c]);l.originalType=e,l.mdxType="string"==typeof e?e:o,i[1]=l;for(var s=2;s<r;s++)i[s]=n[s];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},5955:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return i},contentTitle:function(){return l},metadata:function(){return c},toc:function(){return s},default:function(){return p}});var a=n(2122),o=n(9756),r=(n(7294),n(3905)),i={id:"fly-controls",title:"Three.js Fly Controls"},l=void 0,c={unversionedId:"extension/fly-controls",id:"extension/fly-controls",isDocsHomePage:!1,title:"Three.js Fly Controls",description:"MapillaryJS comes with two different camera controls, Street and Earth. Street mode is for navigating at the street level while Earth mode works more like a map. When using MapillaryJS, you may want to interact with the visualized content in another way. You can do that by extending MapillaryJS with custom camera controls. Custom camera controls allow you to freely move the viewer's camera and define the camera projection used.",source:"@site/docs/extension/fly-controls.md",sourceDirName:"extension",slug:"/extension/fly-controls",permalink:"/mapillary-js/docs/extension/fly-controls",editUrl:"https://github.com/mapillary/mapillary-js/edit/main/doc/docs/extension/fly-controls.md",tags:[],version:"current",frontMatter:{id:"fly-controls",title:"Three.js Fly Controls"},sidebar:"docs",previous:{title:"Graphics Developer",permalink:"/mapillary-js/docs/extension/graphics-developer"},next:{title:"Theory",permalink:"/mapillary-js/docs/theory/theory"}},s=[{value:"Creating the Camera Controls",id:"creating-the-camera-controls",children:[{value:"<code>constructor</code>",id:"constructor",children:[]},{value:"<code>onAttach</code>",id:"onattach",children:[]},{value:"<code>onActivate</code>",id:"onactivate",children:[]},{value:"<code>onAnimationFrame</code>",id:"onanimationframe",children:[]},{value:"<code>onReference</code>",id:"onreference",children:[]},{value:"<code>onResize</code>",id:"onresize",children:[]},{value:"<code>onDeactivate</code>",id:"ondeactivate",children:[]},{value:"<code>onDetach</code>",id:"ondetach",children:[]}]},{value:"Attaching and Detaching",id:"attaching-and-detaching",children:[{value:"Activating and Deactivating",id:"activating-and-deactivating",children:[]}]},{value:"Putting the Controls to Use",id:"putting-the-controls-to-use",children:[]},{value:"Recap",id:"recap",children:[]}],m={toc:s};function p(e){var t=e.components,n=(0,o.Z)(e,["components"]);return(0,r.kt)("wrapper",(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"MapillaryJS comes with two different camera controls, ",(0,r.kt)("inlineCode",{parentName:"p"},"Street")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Earth"),". ",(0,r.kt)("inlineCode",{parentName:"p"},"Street")," mode is for navigating at the street level while ",(0,r.kt)("inlineCode",{parentName:"p"},"Earth")," mode works more like a map. When using MapillaryJS, you may want to interact with the visualized content in another way. You can do that by extending MapillaryJS with custom camera controls. Custom camera controls allow you to freely move the viewer's camera and define the camera projection used."),(0,r.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,r.kt)("div",{parentName:"div",className:"admonition-heading"},(0,r.kt)("h5",{parentName:"div"},(0,r.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,r.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,r.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"You will learn")),(0,r.kt)("div",{parentName:"div",className:"admonition-content"},(0,r.kt)("ul",{parentName:"div"},(0,r.kt)("li",{parentName:"ul"},"How to use the Three.js fly controls to define the camera behavior"),(0,r.kt)("li",{parentName:"ul"},"How to implement the ",(0,r.kt)("inlineCode",{parentName:"li"},"ICustomCameraControls")," interface"),(0,r.kt)("li",{parentName:"ul"},"How to attach your camera controls to the ",(0,r.kt)("inlineCode",{parentName:"li"},"Viewer")),(0,r.kt)("li",{parentName:"ul"},"How to activate your camera controls")))),(0,r.kt)("h2",{id:"creating-the-camera-controls"},"Creating the Camera Controls"),(0,r.kt)("p",null,"In the data provider and custom render examples we worked with both ",(0,r.kt)("a",{parentName:"p",href:"/docs/theory/coordinates#geodetic-coordinates"},"geodetic")," and ",(0,r.kt)("a",{parentName:"p",href:"/docs/theory/coordinates#local-topocentric-coordinates"},"local topocentric")," coordinates and converted between them. For camera controls, we mainly operate in the local topocentric space, but will also do some coordiante conversions."),(0,r.kt)("p",null,"To create our fly controls, we will implement the ",(0,r.kt)("a",{parentName:"p",href:"/api/interfaces/viewer.icustomcameracontrols"},"ICustomCameraControls")," interface. Let us go through the interface implementation member by member."),(0,r.kt)("h3",{id:"constructor"},(0,r.kt)("inlineCode",{parentName:"h3"},"constructor")),(0,r.kt)("p",null,"We can use the constructor to assign some readonly visualization options for our controls."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"class FlyCameraControls {\n  constructor() {\n    this.fov = options.fov;\n    this.movementSpeed = options.movementSpeed;\n    this.rollSpeed = options.rollSpeed;\n  }\n  // ...\n}\n")),(0,r.kt)("h3",{id:"onattach"},(0,r.kt)("inlineCode",{parentName:"h3"},"onAttach")),(0,r.kt)("p",null,"ICustomCameraControls.",(0,r.kt)("a",{parentName:"p",href:"/api/interfaces/viewer.icustomcameracontrols#onattach"},"onAttach")," is called when the controls have been attached to the ",(0,r.kt)("inlineCode",{parentName:"p"},"Viewer")," with the Viewer.",(0,r.kt)("a",{parentName:"p",href:"/api/classes/viewer.Viewer#attachcustomcameracontrols"},"attachCustomCameraControls")," method. ",(0,r.kt)("inlineCode",{parentName:"p"},"onAttach")," provides two important callback parameters, ",(0,r.kt)("inlineCode",{parentName:"p"},"viewMatrixCallback")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"projectionMatrixCallback"),". You should invoke these callbacks to modify the pose and projection of the ",(0,r.kt)("inlineCode",{parentName:"p"},"Viewer"),"'s camera whenever the controls causes an update."),(0,r.kt)("p",null,"Custom camera controls trigger rerendering automatically when the camera pose or projection is changed through the ",(0,r.kt)("inlineCode",{parentName:"p"},"viewMatrixCallback")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"projectionMatrixCallback"),". Invoking the callbacks has no effect if custom camera controls has not been ",(0,r.kt)("a",{parentName:"p",href:"/docs/extension/fly-controls#activating-and-deactivating"},"activated"),"."),(0,r.kt)("p",null,"In our controls ",(0,r.kt)("inlineCode",{parentName:"p"},"onAttach")," implementation, we assign the callback parameters to instance properties to be able to invoke them later."),(0,r.kt)("div",{className:"admonition admonition-tip alert alert--success"},(0,r.kt)("div",{parentName:"div",className:"admonition-heading"},(0,r.kt)("h5",{parentName:"div"},(0,r.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,r.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,r.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"tip")),(0,r.kt)("div",{parentName:"div",className:"admonition-content"},(0,r.kt)("p",{parentName:"div"},"If you want to learn more about view, and projection matrices, take a look at the ",(0,r.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_model_view_projection"},"WebGL model view projection article")," on MDN."))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"class FlyCameraControls {\n  // ...\n  onAttach(viewer, viewMatrixCallback, projectionMatrixCallback) {\n    this.viewMatrixCallback = viewMatrixCallback;\n    this.projectionMatrixCallback = projectionMatrixCallback;\n  }\n}\n")),(0,r.kt)("h3",{id:"onactivate"},(0,r.kt)("inlineCode",{parentName:"h3"},"onActivate")),(0,r.kt)("p",null,"When our controls are activated, they take responsibility for moving the ",(0,r.kt)("inlineCode",{parentName:"p"},"Viewer"),"'s camera and defining it's projection. The ICustomCameraControls.",(0,r.kt)("a",{parentName:"p",href:"/api/interfaces/viewer.icustomcameracontrols#onactivate"},"onActivate")," method gives the camera controls a chance to initialize resources, perform any transitions, and determine initial state."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"onActivate")," provides four parameters that we can use for initialization. Let's go through the matrix parameters in detail."),(0,r.kt)("h4",{id:"viewmatrix"},(0,r.kt)("inlineCode",{parentName:"h4"},"viewMatrix")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"viewMatrix")," array contains the ",(0,r.kt)("inlineCode",{parentName:"p"},"Viewer")," view matrix entries for the moment our controls were activated. We can use the entries of the ",(0,r.kt)("inlineCode",{parentName:"p"},"viewMatrix"),", and particularly the ",(0,r.kt)("inlineCode",{parentName:"p"},"viewMatrix")," inverse, to determine initial properties such as eye, forward, and up vectors. We can also use them to transition smoothly so another position."),(0,r.kt)("h4",{id:"projectionmatrix"},(0,r.kt)("inlineCode",{parentName:"h4"},"projectionMatrix")),(0,r.kt)("p",null,"Simpilar to the ",(0,r.kt)("inlineCode",{parentName:"p"},"viewMatrix"),", the ",(0,r.kt)("inlineCode",{parentName:"p"},"projectionMatrix")," array contains the ",(0,r.kt)("inlineCode",{parentName:"p"},"Viewer")," projection matrix entries for the moment our controls were activated. We can use the projection matrix entries to determine the initial projection if we want a smooth transition."),(0,r.kt)("h4",{id:"implementation"},"Implementation"),(0,r.kt)("p",null,"Our ",(0,r.kt)("inlineCode",{parentName:"p"},"onActivate")," implementation consist of the following steps."),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"We save the geodetic reference for the future in case it changes."),(0,r.kt)("li",{parentName:"ol"},"We use the Viewer.",(0,r.kt)("a",{parentName:"li",href:"/api/classes/viewer.Viewer#getcontainer"},"getContainer")," method to get the container for determining the viewer aspect and create a ",(0,r.kt)("a",{parentName:"li",href:"https://threejs.org/docs/index.html?q=perspe#api/en/cameras/PerspectiveCamera"},"PerspectiveCamera"),". We want up to correspond to the Z-axis initially so we rotate the camera 90 degrees."),(0,r.kt)("li",{parentName:"ol"},"We create the fly controls, providing the camera and the container for attaching event handlers (which happens in the Three.js FlyControls constructor)."),(0,r.kt)("li",{parentName:"ol"},"We use the ",(0,r.kt)("inlineCode",{parentName:"li"},"viewMatrix")," inverse to set the initial camera position to the current ",(0,r.kt)("inlineCode",{parentName:"li"},"Viewer")," position."),(0,r.kt)("li",{parentName:"ol"},"We create an event listener invoking the ",(0,r.kt)("inlineCode",{parentName:"li"},"viewMatrixCallback")," whenever the controls emits a change."),(0,r.kt)("li",{parentName:"ol"},"Finally, we invoke the callbacks to update the ",(0,r.kt)("inlineCode",{parentName:"li"},"Viewer")," camera with our initialized view and projection matrices. Note that we make sure to update both matrices properly before invoking the callbacks.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"class FlyCameraControls {\n  // ...\n  onActivate(viewer, viewMatrix, projectionMatrix, reference) {\n    this.reference = reference;\n\n    const {fov, movementSpeed, rollSpeed} = this;\n\n    // Create camera\n    const container = viewer.getContainer();\n    const aspect = calcAspect(container);\n    const camera = new PerspectiveCamera(fov, aspect, 0.1, 10000);\n    camera.rotateX(Math.PI / 2);\n\n    // Create controls\n    this.controls = new FlyControls(camera, container);\n    this.controls.movementSpeed = movementSpeed;\n    this.controls.rollSpeed = rollSpeed;\n\n    // Set camera position\n    const viewMatrixInverse = new Matrix4().fromArray(viewMatrix).invert();\n    const me = viewMatrixInverse.elements;\n    const translation = [me[12], me[13], me[14]];\n    this.controls.object.position.fromArray(translation);\n\n    // Listen to control changes\n    this.onControlsChange = () => {\n      this.controls.object.updateMatrixWorld(true);\n      this.viewMatrixCallback(\n        this.controls.object.matrixWorldInverse.toArray(),\n      );\n    };\n    this.controls.addEventListener('change', this.onControlsChange);\n\n    // Update pose and projection\n    this.clock = new Clock();\n    const delta = this.clock.getDelta();\n    this.controls.update(delta);\n\n    camera.updateProjectionMatrix();\n    this.projectionMatrixCallback(camera.projectionMatrix.toArray());\n  }\n}\n")),(0,r.kt)("h3",{id:"onanimationframe"},(0,r.kt)("inlineCode",{parentName:"h3"},"onAnimationFrame")),(0,r.kt)("p",null,"Custom camera controls can choose to make updates on each animation frame or based on input events only. Updating on each animation frame is more resource intensive. We will make a call to update the fly controls on each animation frame. The controls will notify our ",(0,r.kt)("inlineCode",{parentName:"p"},"change")," event listener whenever its pose has changed."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"class FlyCameraControls {\n  // ...\n  onAnimationFrame(_viewer, _frameId) {\n    const delta = this.clock.getDelta();\n    this.controls.update(delta);\n  }\n}\n")),(0,r.kt)("h3",{id:"onreference"},(0,r.kt)("inlineCode",{parentName:"h3"},"onReference")),(0,r.kt)("p",null,"Like ",(0,r.kt)("a",{parentName:"p",href:"/docs/extension/webgl-custom-renderer#onreference"},"custom renderers"),", we need to handle updates to the MapillaryJS geodetic reference. We do that in the ",(0,r.kt)("inlineCode",{parentName:"p"},"onReference")," method by first calculating the camera's geodetic coordinates using the previous reference. Then we calculate the new local topocentric east, north, up position using the current reference. We make sure that the camera matrices are updated and the current reference is saved."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"class FlyCameraControls {\n  // ...\n  onReference(viewer, reference) {\n    const oldReference = this.reference;\n\n    const enu = this.controls.object.position;\n    const [lng, lat, alt] = enuToGeodetic(\n      enu.x,\n      enu.y,\n      enu.z,\n      oldReference.lng,\n      oldReference.lat,\n      oldReference.alt,\n    );\n    const [e, n, u] = geodeticToEnu(\n      lng,\n      lat,\n      alt,\n      reference.lng,\n      reference.lat,\n      reference.alt,\n    );\n\n    this.controls.object.position.set(e, n, u);\n    this.controls.object.updateMatrixWorld(true);\n\n    this.reference = reference;\n  }\n}\n")),(0,r.kt)("h3",{id:"onresize"},(0,r.kt)("inlineCode",{parentName:"h3"},"onResize")),(0,r.kt)("p",null,"Whenever the ",(0,r.kt)("inlineCode",{parentName:"p"},"Viewer")," detects that it is resized, either through ",(0,r.kt)("a",{parentName:"p",href:"/api/interfaces/viewer.vieweroptions#trackresize"},"browser resize tracking")," or through you informing it with the Viewer.(resize)","[/api/classes/viewer.Viewer#resize]"," method, it will notify our camera controls. This gives us a chance to recalculate the aspect and update the projection matrix."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"class FlyCameraControls {\n  // ...\n  onResize(_viewer) {\n    const camera = this.controls.object;\n    camera.aspect = calcAspect(this.controls.domElement);\n    camera.updateProjectionMatrix();\n    this.projectionMatrixCallback(camera.projectionMatrix.toArray());\n  }\n}\n")),(0,r.kt)("h3",{id:"ondeactivate"},(0,r.kt)("inlineCode",{parentName:"h3"},"onDeactivate")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"onDeactivate")," method is called when other camera controls are activated with the Viewer.",(0,r.kt)("a",{parentName:"p",href:"/api/classes/viewer.Viewer#setcameracontrols"},"setCameraControls")," method. We use the ",(0,r.kt)("inlineCode",{parentName:"p"},"onDeactivate")," method to dispose the fly controls and remove our event listener. Note that our controls are still attached to the ",(0,r.kt)("inlineCode",{parentName:"p"},"Viewer")," and may be activated again in the future."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"class FlyCameraControls {\n  // ...\n  onDeactivate(_viewer) {\n    if (this.controls) {\n      this.controls.removeEventListener('change', this.onControlsChange);\n      this.controls.dispose();\n      this.controls = null;\n    }\n  }\n}\n")),(0,r.kt)("h3",{id:"ondetach"},(0,r.kt)("inlineCode",{parentName:"h3"},"onDetach")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"onDetach")," method is called when the camera controls have been detached from the viewer by calling Viewer.",(0,r.kt)("a",{parentName:"p",href:"/api/classes/viewer.Viewer#detachcustomcameracontrols"},"detachCameraControls"),". This gives use a chance to remove the matrix callbacks."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"class FlyCameraControls {\n  // ...\n  onDetach(_viewer) {\n    this.projectionMatrixCallback = null;\n    this.viewMatrixCallback = null;\n  }\n}\n")),(0,r.kt)("h2",{id:"attaching-and-detaching"},"Attaching and Detaching"),(0,r.kt)("p",null,"Only a single custom camera control instance can be attached to the ",(0,r.kt)("inlineCode",{parentName:"p"},"Viewer")," at any given time. A controls instance is attached with the Viewer.",(0,r.kt)("a",{parentName:"p",href:"/api/classes/viewer.Viewer#attachcustomcameracontrols"},"attachCustomCameraControls")," method. Although only a single control instance can be attached at any given time, multiple different controls can be used during the ",(0,r.kt)("inlineCode",{parentName:"p"},"Viewer")," lifespan. By detaching a controls instance with the Viewer.",(0,r.kt)("a",{parentName:"p",href:"/api/classes/viewer.Viewer#detachcustomcameracontrols"},"detachCustomCameraControls")," method, another controls instance can be attached."),(0,r.kt)("h3",{id:"activating-and-deactivating"},"Activating and Deactivating"),(0,r.kt)("p",null,"You can activate an attached controls instance in two ways."),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Use the the ViewerOptions.",(0,r.kt)("a",{parentName:"li",href:"/api/interfaces/viewer.vieweroptions#cameracontrols"},"cameraControls")," option to specify the CameraControls.",(0,r.kt)("a",{parentName:"li",href:"/api/enums/viewer.cameracontrols#custom"},"Custom")," mode upon initialization."),(0,r.kt)("li",{parentName:"ol"},"Set the ",(0,r.kt)("inlineCode",{parentName:"li"},"Custom")," mode with the Viewer.",(0,r.kt)("a",{parentName:"li",href:"/api/classes/viewer.Viewer#setcameracontrols"},"setCameraControls")," method at any time during the ",(0,r.kt)("inlineCode",{parentName:"li"},"Viewer")," lifespan.")),(0,r.kt)("p",null,"Deactivating the custom controls is done by calling the Viewer.",(0,r.kt)("a",{parentName:"p",href:"/api/classes/viewer.Viewer#setcameracontrols"},"setCameraControls")," method with any oother ","[CameraControls]"," mode."),(0,r.kt)("h2",{id:"putting-the-controls-to-use"},"Putting the Controls to Use"),(0,r.kt)("p",null,"Now that we have implemented our custom cube renderer, we just need to add it to the ",(0,r.kt)("inlineCode",{parentName:"p"},"Viewer")," through the Viewer.",(0,r.kt)("a",{parentName:"p",href:"/api/classes/viewer.Viewer#addcustomrenderer"},"addCustomRenderer")," method."),(0,r.kt)("div",{className:"admonition admonition-tip alert alert--success"},(0,r.kt)("div",{parentName:"div",className:"admonition-heading"},(0,r.kt)("h5",{parentName:"div"},(0,r.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,r.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,r.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"tip")),(0,r.kt)("div",{parentName:"div",className:"admonition-content"},(0,r.kt)("p",{parentName:"div"},"Press the left button to fly forward and the right button to fly backward or use the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/mrdoob/three.js/blob/r125/examples/jsm/controls/FlyControls.js#L57-L76"},"fly key commands")," for specific motion."),(0,r.kt)("p",{parentName:"div"},"Try to initialize the ",(0,r.kt)("inlineCode",{parentName:"p"},"Viewer")," with ",(0,r.kt)("inlineCode",{parentName:"p"},"Street")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"Earth")," controls and change to the ",(0,r.kt)("inlineCode",{parentName:"p"},"Custom")," controls by calling Viewer.",(0,r.kt)("inlineCode",{parentName:"p"},"setCameraControls"),". Try changing the fly options to see how they affect the viewport and camera behavior."))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx",metastring:"live",live:!0},"function render(props) {\n  let viewer;\n\n  function init(opts) {\n    const {accessToken, container} = opts;\n\n    const imageId = '578479680210256';\n    const cameraControls = CameraControls.Custom;\n    const options = {\n      accessToken,\n      cameraControls,\n      component: {\n        cover: false,\n        direction: false,\n        spatial: {cameraSize: 0.8, cellsVisible: true, pointSize: 0.2},\n      },\n      container,\n    };\n    viewer = new Viewer(options);\n\n    const flyOptions = {\n      fov: 90,\n      movementSpeed: 30,\n      rollSpeed: 0.25,\n    };\n    const flyControls = new flycontrols.FlyCameraControls(flyOptions);\n    viewer.attachCustomCameraControls(flyControls);\n\n    viewer.moveTo(imageId).catch(mapillaryErrorHandler);\n  }\n\n  function dispose() {\n    if (viewer) {\n      viewer.remove();\n    }\n  }\n\n  return (\n    <ViewerComponent init={init} dispose={dispose} style={{height: '400px'}} />\n  );\n}\n")),(0,r.kt)("h2",{id:"recap"},"Recap"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"To add custom camera controls to MapillaryJS, implement the ",(0,r.kt)("inlineCode",{parentName:"li"},"ICustomCameraControls")," interface"),(0,r.kt)("li",{parentName:"ul"},"Setup your controls in the ",(0,r.kt)("inlineCode",{parentName:"li"},"onActivate")," method"),(0,r.kt)("li",{parentName:"ul"},"Invoke the ",(0,r.kt)("inlineCode",{parentName:"li"},"viewMatrix")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"projectionMatrix")," callbacks whenever your camera pose or projection is updated"),(0,r.kt)("li",{parentName:"ul"},"Make use of any of the Three.js controls if they cover your use case"),(0,r.kt)("li",{parentName:"ul"},"Attach your custom camera controls to the ",(0,r.kt)("inlineCode",{parentName:"li"},"Viewer")," and activate ",(0,r.kt)("inlineCode",{parentName:"li"},"Custom")," mode to put them to use")),(0,r.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,r.kt)("div",{parentName:"div",className:"admonition-heading"},(0,r.kt)("h5",{parentName:"div"},(0,r.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,r.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,r.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"info")),(0,r.kt)("div",{parentName:"div",className:"admonition-content"},(0,r.kt)("p",{parentName:"div"},"You can view the complete code in the ",(0,r.kt)("a",{parentName:"p",href:"/examples/extend-fly-controls"},"Fly Controls")," example."),(0,r.kt)("p",{parentName:"div"},"For another example of custom camera controls leveraging Three.js, you can take a look at the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/mapillary/OpenSfM/blob/398fe61fd970c7fa80b10b56606643408fa3dd7e/viewer/src/ui/OrbitCameraControls.js"},"OpenSfM orbit camera controls"),"."))))}p.isMDXComponent=!0}}]);